import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.style.use('seaborn')
import statsmodels.api as sm
from statsmodels.formula.api import ols
from linearmodels.iv import IV2SLS
from scipy.stats import zscore

klein = pd.read_fwf("http://people.stern.nyu.edu/wgreene/Text/Edition7/TableF10-3.txt")
klein.dropna(inplace=True)
klein['Year'] = klein['Year'].astype(int)
klein.index = pd.period_range(start=klein['Year'].iloc[0], periods=klein.shape[0], freq="A")
del klein['Year']

datanames = dict(
  C="consumo",
  P="utilidades corporativas",
  Wp="salarios sector privado",
  I="inversión",
  K1="stock de capital del año anterior",
  X="producto nacional bruto",
  Wg="salarios sector público",
  G="gasto del gobierno",
  T="impuestos")

klein.rename(columns=datanames).plot(
  subplots=True, figsize=[12,9], layout=[-1,3]);

# La variable `K1` en la base de datos corresponde al *rezago* del capital, por lo que generamos `K`. Además, generamos la tendencia y el intercepto.

klein['A'] = np.arange(klein.shape[0]) - 11
klein['interc'] = 1

# Generamos las variables predeterminadas y la suma de salarios
klein['P1'] = klein['P'].shift(1)
klein['X1'] = klein['X'].shift(1)
klein['W'] = klein['Wp'] + klein['Wg']

klein.dropna(inplace=True);

# Clasificamos las variables en tres grupos: endógenas, exogenas, y predeterminadas

endogenas = ['C', 'I', 'Wp', 'X', 'P']
exogenas = ['interc', 'G', 'T', 'Wg', 'A']
predeterminadas = ['K1', 'P1', 'X1']

regresores_eqs = [
  ['interc', 'P', 'P1', 'W'],
  ['interc', 'P', 'P1', 'K1'],
  ['interc', 'X', 'X1', 'A']]

Y = klein[endogenas]
X = klein[exogenas+predeterminadas]

beta = np.linalg.solve(X.T@X, X.T@Y)
beta = pd.DataFrame(beta, columns=endogenas, index=exogenas+predeterminadas)

yhat = X@beta
beta.style.format("{:.2f}", na_rep=" ")

# Preparar datos para la segunda etapa

# Definir lista de instrumentos para cada ecuación: esta lista es igual a la lista de regresores original, pero sustituyendo las endógenas por su valor ajustado de la etapa 1

klein_ols = pd.concat([yhat, klein[exogenas+predeterminadas]], axis=1)
klein_ols['W'] = klein_ols['Wp'] + klein_ols['Wg']

# Etapa 2
coef2sls = []
for xx, yy in zip(regresores_eqs, endogenas[:3]):
    X1, y1 = klein_ols[xx], klein_ols[yy]
    beta1 = np.linalg.solve(X1.T@X1, X1.T@y1)
    coef2sls.append(pd.Series(beta1.ravel(), index=xx, name=yy))
pd.concat(coef2sls, axis=1, sort=False).style.format("{:.2f}", na_rep=" ")

IV2SLS.from_formula('C ~ 1 + [P + W ~ G + T + Wg + A + K1 + X1] + P1', klein).fit().summary

IV2SLS.from_formula('I ~ 1 + [P ~ G + T + Wg + A + X1] + P1 + K1', klein).fit().summary

IV2SLS.from_formula('Wp ~ 1 + [X ~ G + T + Wg + K1 + P1] + X1 + A', klein).fit().summary

# Definimos los parámetros del modelo
endogenas = ['Q_maiz','Q_trigo','P_maiz','P_trigo']

Gamma = np.array([      # RELACIÓN SIMULTANEA
    [1, 0,   0,    0],  # oferta maiz
    [0, 1,   0,    0],  # oferta trigo
    [1, 0, 0.2, -1.2],  # demanda maiz
    [0, 1,-1.1, 0.4]])  # demanda trigo

cstr = np.array([200,80,100,50])  # interceptos forma estructural

Beta = np.array([  # PENDIENTES ESTRUCTURALES
    [ 0.5, -0.2],  # oferta maiz
    [-0.2,  0.4],  # oferta trigo
    [   0,    0],  # demanda maiz
    [   0,    0]]) # demanda trigo


# A partir de la inversa de Γ, obtenemos los parámetros de la forma reducida
Gammainv = np.linalg.inv(Gamma)

cred = Gammainv @ cstr # interceptos forma reducida
Pi = Gammainv @ Beta   # pendientes forma reducida

# Definimos la función *telaraña*, la cual simula $T$ observaciones de los precios y cantidades de trigo, luego de desechar las primeras *drop* observaciones. El resultado se retorna como una tabla de *Pandas*, la cual facilita la creación de gráficos y la estimación econométrica posterior.

def telaraña(T, drop=10, estocastico=True):
    if estocastico:
        e_struc = np.random.randn(T+drop,4)
        e_reduc = e_struc @ Gammainv.T
    else:
        e_reduc = np.zeros((T+drop,4))

    y = np.zeros((T+drop,4))
    y[0,-2:] = [120, 70]
    for t in range(T+drop-1):
        y[t+1] = cred + Pi @ y[t,-2:] + e_reduc[t+1]
    return pd.DataFrame(y[drop:], columns=endogenas)


telaraña(100).plot(subplots=True, layout=[2,2], figsize=[12,6], sharex=True);

NSIMUL = 1000

def telaraña_con_precios_rezagos(T=24):
    datos = telaraña(T)
    datos['LP_maiz'] = datos['P_maiz'].shift()   # precio maiz rezagado
    datos['LP_trigo'] = datos['P_trigo'].shift() # precio trigo rezagado
    return datos

np.random.seed(123)
DATOS_SIMULADOS = pd.concat(
  [telaraña_con_precios_rezagos() for n in range(NSIMUL)],
  keys = range(NSIMUL)
  )

def ols_params(modelo):
    return pd.DataFrame(
      [ols(modelo, df.loc[_]).fit().params
         for _, df in DATOS_SIMULADOS.groupby(level=0)]
       )

def tsls_params(modelo):
    return pd.DataFrame(
        [IV2SLS.from_formula(modelo,df.dropna()).fit().params
         for i, df in DATOS_SIMULADOS.groupby(level=0)])


PARAMETROS_SIMULADOS = {
 'ms_ols': ols_params('Q_maiz ~ 1 + LP_maiz + LP_trigo'),
 'ws_ols': ols_params('Q_trigo ~ 1 + LP_maiz + LP_trigo'),
 'md_ols': ols_params('Q_maiz ~ 1 + P_maiz + P_trigo'),
 'wd_ols': ols_params('Q_trigo ~ 1 + P_maiz + P_trigo'),
 'md_2sls': tsls_params('Q_maiz ~ 1 + [P_maiz + P_trigo ~ LP_maiz + LP_trigo]'),
 'wd_2sls': tsls_params('Q_trigo ~ 1 + [P_maiz + P_trigo ~ LP_maiz + LP_trigo]')
}

true_params = {
    'ms': np.r_[cstr[0],Beta[0]],
    'ws': np.r_[cstr[1],Beta[1]],
    'md': np.r_[cstr[2], -Gamma[2,-2:]],
    'wd': np.r_[cstr[3], -Gamma[3,-2:]]}

description = {
    'ms': 'Oferta de maíz',
    'ws': 'Oferta de trigo',
    'md': 'Demanda de maíz',
    'wd': 'Demanda de trigo'}

def plot_result(caso, remove_outlier=False):
    simul = PARAMETROS_SIMULADOS[caso]

    # remove outliers
    if remove_outlier:
        not_outlier = (np.abs(zscore(simul)) < 3).all(axis=1)
        print(f'Se detectaron {(~not_outlier).sum()} outliers')
        simul = simul[not_outlier]

    fig, axs = plt.subplots(1,3,figsize=[12,3])
    true_values = true_params[caso[:2]]
    for ax, serie, xv in zip(axs, simul, true_values):
        simul[serie].hist(bins=20,ax=ax, alpha=0.75)
        ax.axvline(x=xv,linewidth=4, color='r')
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)
        ax.set(yticks=[], xlabel=serie)
        ax.grid(False)
    fig.suptitle(description[caso[:2]], size=16)
    return pd.DataFrame({'promedio': simul.mean(),
                         'verdadero': true_values}).round(3).T

plot_result('ms_ols')

plot_result('ws_ols')

plot_result('md_ols')

plot_result('wd_ols')

plot_result('md_2sls', True)

plot_result('wd_2sls', True)
